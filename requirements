#!/usr/bin/env bash
set -euo pipefail

if [[ -n "${REQUIREMENTS_CONFIG:-}" ]]; then
  CONFIG="$REQUIREMENTS_CONFIG"
else
  CONFIG="$PWD/requirements.ini"
fi
readonly CONFIG

if [[ ! -f "$CONFIG" ]]; then
  echo "Arquivo de configuração '$CONFIG' não encontrado." >&2
  exit 1
fi

# ───────────────────────────────────────────────────────────────────────────────
# 🎨 Configurações de ícones
# ───────────────────────────────────────────────────────────────────────────────

readonly ICON_SUCCESS="✅"
readonly ICON_INFO="🔸"
readonly ICON_DEP_MID="├─"
readonly ICON_DEP_END="└─"
readonly ICON_NO_DEPS=""
readonly ICON_APPLY_CMD="▶️"
readonly ICON_FAIL="❌"
readonly ICON_WARN="⚠️"
readonly ICON_REVERT="🗑️"
readonly ICON_SPINNER="⏳"
readonly ICON_SUMMARY="📋"
readonly ICON_DONE="🎉"
readonly ICON_SKIPPED="🔄"

# ───────────────────────────────────────────────────────────────────────────────
# 🌈 Dependência opcional: gum
# ───────────────────────────────────────────────────────────────────────────────

readonly GUM_TIME_FORMAT="kitchen"

function has_gum() {
  command -v gum >/dev/null 2>&1
}

# ───────────────────────────────────────────────────────────────────────────────
# 🧾 Logging com suporte a gum
# ───────────────────────────────────────────────────────────────────────────────

function log_info() {
  if has_gum; then
    gum log --time="$GUM_TIME_FORMAT" --level info "$1"
  else
    echo -e "\e[34m$1\e[0m"
  fi
}

function log_success() {
  if has_gum; then
    gum log --time="$GUM_TIME_FORMAT" --level info "$1"
  else
    echo -e "\e[32m$1\e[0m"
  fi
}

function log_error() {
  if has_gum; then
    gum log --time="$GUM_TIME_FORMAT" --level error "$1"
  else
    echo -e "\e[31m$1\e[0m"
  fi
}

# ───────────────────────────────────────────────────────────────────────────────
# 💻 TUI (interface interativa com ou sem gum)
# ───────────────────────────────────────────────────────────────────────────────

function tui_confirm() {
  if has_gum; then
    gum confirm "$1"
  else
    read -rp "$1 [y/N]: " yn
    [[ "$yn" =~ ^[Yy]$ ]]
  fi
}

function tui_spinner() {
  local msg="$1"
  shift
  if has_gum; then
    gum spin --spinner dot --title "$msg" -- "$@"
  else
    echo "$ICON_SPINNER $msg..."
    "$@"
  fi
}

function tui_preview() {
  local preview="$1"
  if has_gum; then
    gum style "── Comandos a executar ──" --bold
    echo "$preview" | head -n 5 | gum style --foreground 244
    echo
    gum style "Deseja continuar?" --foreground 212 --bold
    local choice
    choice=$(echo -e "Sim\nNão" | gum choose --height=2 --cursor="👉" || true)
    if [[ "$choice" != "Sim" ]]; then
      log_info "🚫 Execução cancelada pelo usuário."
      exit 0
    fi
  else
    echo "── Comandos a executar ──"
    echo "$preview"
    read -rp "Deseja continuar com a execução? [y/N]: " yn
    [[ "$yn" =~ ^[Yy]$ ]] || {
      echo "Execução cancelada."
      exit 0
    }
  fi
}

# ───────────────────────────────────────────────────────────────────────────────
# 📄 Utils
# ───────────────────────────────────────────────────────────────────────────────

# Detecta a plataforma atual (darwin, linux, windows)
function detect_platform() {
  case "$(uname -s)" in
    Darwin) echo "darwin" ;;
    Linux) echo "linux" ;;
    MINGW* | MSYS* | CYGWIN*) echo "windows" ;;
    *) echo "all" ;;
  esac
}

# Detecta o gerenciador de pacotes (apt, nix, dnf, brew, pacman, etc.)
function detect_package_manager() {
  if command -v apt-get &>/dev/null; then
    echo "apt"
  elif command -v dnf &>/dev/null; then
    echo "dnf"
  elif command -v yum &>/dev/null; then
    echo "yum"
  elif command -v pacman &>/dev/null; then
    echo "pacman"
  elif command -v zypper &>/dev/null; then
    echo "zypper"
  elif command -v nix-env &>/dev/null; then
    echo "nix"
  elif command -v brew &>/dev/null; then
    echo "brew"
  elif command -v choco &>/dev/null; then
    echo "choco"
  elif command -v scoop &>/dev/null; then
    echo "scoop"
  else
    echo "unknown"
  fi
}

function trim() {
  local var="$*"
  var="${var#"${var%%[![:space:]]*}"}"
  var="${var%"${var##*[![:space:]]}"}"
  echo -n "$var"
}

# ───────────────────────────────────────────────────────────────────────────────
# 📄 INI Parsing
# ───────────────────────────────────────────────────────────────────────────────

function get_section_name() {
  [[ "$1" =~ ^\[(.*)\]$ ]] && echo "${BASH_REMATCH[1]}" || echo ""
}

function section_exists() {
  grep -q "^\[$1\]$" "$CONFIG"
}

function ini_get_value() {
  local section="$1" key="$2" in_section=0
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    local current_section
    current_section=$(get_section_name "$line")
    if [[ -n "$current_section" ]]; then
      in_section=$([[ "$current_section" == "$section" ]] && echo 1 || echo 0)
      continue
    fi
    if ((in_section)) && [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
      local k value
      k=$(trim "${BASH_REMATCH[1]}")
      value=$(trim "${BASH_REMATCH[2]}")
      [[ "$k" == "$key" ]] && echo "$value" && return 0
    fi
  done <"$CONFIG"
  echo "Chave '$key' na seção '$section' não encontrada." >&2
  return 1
}

function ini_get_values() {
  local section="$1" key="$2" in_section=0 values=()
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    local current_section
    current_section=$(get_section_name "$line")
    if [[ -n "$current_section" ]]; then
      in_section=$([[ "$current_section" == "$section" ]] && echo 1 || echo 0)
      continue
    fi
    if ((in_section)) && [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
      local k value
      k=$(trim "${BASH_REMATCH[1]}")
      value=$(trim "${BASH_REMATCH[2]}")
      [[ "$k" == "$key" || "$k" == "${key}[]" ]] && values+=("$value")
    fi
  done <"$CONFIG"
  printf '%s\n' "${values[@]}"
}

# ───────────────────────────────────────────────────────────────────────────────
# 🔧 Configurações iniciais e estado global
# ───────────────────────────────────────────────────────────────────────────────

PLATFORM=$(detect_platform)
readonly PLATFORM

PACKAGE_MANAGER=$(detect_package_manager)
readonly PACKAGE_MANAGER
log_info "Gerenciador de pacotes detectado: $PACKAGE_MANAGER"

declare -A STATUS
declare -a APPLIED=() SKIPPED=() FAILED=() REVERTED=() UNSKIPPED=()
declare -i STRICT=0 ONLY_MISSING=0 REVERT=0 ALL=0 SHOW_PREVIEW=0
declare -a STAGES=() VISITED=()

# ───────────────────────────────────────────────────────────────────────────────
# ⚙️ Execução de Etapas
# ───────────────────────────────────────────────────────────────────────────────

function remove_from_visited() {
  local to_remove="$1"
  local new_visited=()
  for item in "${VISITED[@]}"; do
    [[ "$item" != "$to_remove" ]] && new_visited+=("$item")
  done
  VISITED=("${new_visited[@]}")
}

function run_stage() {
  local stage="$1"

  # ciclo detectado?
  if [[ " ${VISITED[*]} " == *" $stage "* ]]; then
    log_error "$ICON_FAIL ciclo de dependência detectado em '$stage' -> ${VISITED[*]}"
    exit 1
  fi
  VISITED+=("$stage")

  section_exists "$stage" || {
    log_error "$ICON_FAIL Etapa '$stage' não encontrada."
    STATUS[$stage]="failed"
    FAILED+=("$stage")
    remove_from_visited "$stage"
    return
  }

  [[ -n "${STATUS[$stage]:-}" ]] && {
    remove_from_visited "$stage"
    return
  }

  log_info "$ICON_INFO$stage"

  local dependsOn=()
  read -ra dependsOn <<<"$(ini_get_values "$stage" "dependsOn")"

  if ((${#dependsOn[@]} > 0)); then
    for i in "${!dependsOn[@]}"; do
      local dep="${dependsOn[$i]}"
      local symbol="$ICON_DEP_MID"
      [[ $i -eq $((${#dependsOn[@]} - 1)) ]] && symbol="$ICON_DEP_END"
      log_info "  $symbol $dep"
    done
  else
    log_info "  $ICON_NO_DEPS"
  fi

  local check
  check=$(ini_get_value "$stage" "check" 2>/dev/null || echo "")

  local run=()
  mapfile -t run < <(ini_get_values "$stage" "apply")

  # Executa as dependências antes
  for dep in "${dependsOn[@]}"; do
    local resolved_dep="$dep"
    if ! section_exists "$dep"; then
      if section_exists "${PLATFORM}.$dep"; then
        resolved_dep="${PLATFORM}.$dep"
      fi
    fi

    if ! section_exists "$resolved_dep"; then
      log_error "$ICON_FAIL Etapa de dependência '$dep' (resolvida como '$resolved_dep') não encontrada."
      STATUS[$stage]="failed"
      FAILED+=("$stage")
      remove_from_visited "$stage"
      return
    fi

    run_stage "$resolved_dep"

    if [[ "${STATUS[$resolved_dep]}" != "applied" && "${STATUS[$resolved_dep]}" != "skipped" ]]; then
      log_error "$ICON_FAIL Falha na dependência '$dep' para '$stage'."
      STATUS[$stage]="failed"
      FAILED+=("$stage")
      remove_from_visited "$stage"
      return
    fi
  done

  # Checa se já está instalado (para --only-missing)
  if ((ONLY_MISSING)) && [[ -n "$check" ]] && eval "$check" &>/dev/null; then
    log_success "$ICON_SUCCESS '$stage' já está instalado."
    STATUS[$stage]="skipped"
    SKIPPED+=("$stage")
    remove_from_visited "$stage"
    return
  fi

  # Checagem geral se está instalado
  if [[ -n "$check" ]] && eval "$check" &>/dev/null; then
    log_success "$ICON_SUCCESS '$stage' já está instalado."
    STATUS[$stage]="skipped"
    SKIPPED+=("$stage")
    remove_from_visited "$stage"
    return
  fi

  # Executa comandos de instalação
  if ((${#run[@]})); then
    log_info "$ICON_APPLY_CMD  Comandos de instalação de '$stage':"

    if ((SHOW_PREVIEW)); then
      local preview=""
      for cmd in "${run[@]}"; do
        preview+="+ $cmd"$'\n'
      done
      tui_preview "$preview"
    fi

    for cmd in "${run[@]}"; do
      if ! tui_spinner "Executando: $cmd" bash -c "$cmd"; then
        if ((STRICT)); then
          log_error "$ICON_FAIL Falha em '$stage': $cmd"
          STATUS[$stage]="failed"
          FAILED+=("$stage")
          remove_from_visited "$stage"
          return
        else
          log_info "$ICON_WARN Falha ignorada em '$stage' (modo não estrito)."
          STATUS[$stage]="skipped"
          SKIPPED+=("$stage")
          remove_from_visited "$stage"
          return
        fi
      fi
    done
    STATUS[$stage]="applied"
    APPLIED+=("$stage")
  else
    log_error "$ICON_FAIL Nenhum comando definido para '$stage'."
    STATUS[$stage]="failed"
    FAILED+=("$stage")
    remove_from_visited "$stage"
    return 1
  fi

  # Depois de terminar, remove o stage da pilha de visita
  remove_from_visited "$stage"
}

function run_revert_stage() {
  local stage="$1"

  section_exists "$stage" || {
    log_error "$ICON_FAIL Etapa '$stage' não encontrada."
    STATUS[$stage]="failed"
    FAILED+=("$stage")
    return 1
  }

  [[ -n "${STATUS[$stage]:-}" ]] && return 0

  log_info "$ICON_REVERT $stage"

  local check
  check=$(ini_get_value "$stage" "check" 2>/dev/null || echo "")
  [[ -n "$check" ]] && ! eval "$check" &>/dev/null && {
    log_info "$ICON_SKIPPED '$stage' já desinstalado."
    STATUS[$stage]="unskipped"
    UNSKIPPED+=("$stage")
    return 0
  }

  local revert_cmds=()
  mapfile -t revert_cmds < <(ini_get_values "$stage" "revert")

  if ((${#revert_cmds[@]})); then
    log_info "$ICON_APPLY_CMD  Executando desinstalação de '$stage':"
    for cmd in "${revert_cmds[@]}"; do
      echo "+ $cmd"
      if ! tui_spinner "Executando: $cmd" bash -c "$cmd"; then
        log_error "$ICON_FAIL Falha ao desinstalar '$stage': $cmd"
        STATUS[$stage]="failed"
        FAILED+=("$stage")
        return 1
      fi
    done
    log_success "$ICON_SUCCESS '$stage' desinstalado com sucesso."
    STATUS[$stage]="reverted"
    REVERTED+=("$stage")
  else
    log_info "ℹ️ Nenhum comando de desinstalação definido para '$stage'."
    STATUS[$stage]="unskipped"
    UNSKIPPED+=("$stage")
    return 1
  fi
}

# ───────────────────────────────────────────────────────────────────────────────
# 📋 Resumo e Parser de argumentos
# ───────────────────────────────────────────────────────────────────────────────

function print_summary() {
  log_info ""
  log_info "$ICON_SUMMARY Resumo da execução:"
  if ((REVERT)); then
    if [[ ${#REVERTED[@]} -gt 0 ]]; then
      log_success "└─ $ICON_SUCCESS Desinstalados: ${REVERTED[*]}"
    else
      log_info "└─ $ICON_SUCCESS Desinstalados: Nenhum"
    fi
  elif [[ ${#APPLIED[@]} -gt 0 ]]; then
    log_success "└─ $ICON_SUCCESS Instalados: ${APPLIED[*]}"
  else
    log_info "└─ $ICON_SUCCESS Instalados: Nenhum"
  fi
  if [[ ${#SKIPPED[@]} -gt 0 ]]; then
    log_info "└─ $ICON_SKIPPED Já estavam instalados / desinstalados: ${SKIPPED[*]}"
  else
    log_info "└─ $ICON_SKIPPED Já estavam instalados / desinstalados: Nenhum"
  fi
  if [[ ${#FAILED[@]} -gt 0 ]]; then
    log_error "└─ $ICON_FAIL Falhas: ${FAILED[*]}"
    log_error "😔 Verifique os erros acima e tente novamente."
    exit 1
  else
    log_success "$ICON_DONE Todas as etapas concluídas com sucesso!"
  fi
}

function parse_args() {
  while (($#)); do
    case "$1" in
      --strict) STRICT=1 ;;
      --only-missing) ONLY_MISSING=1 ;;
      --revert) REVERT=1 ;;
      --all) ALL=1 ;;
      --preview) SHOW_PREVIEW=1 ;;
      *)
        # Checa se existe uma seção com plataforma
        if section_exists "${PLATFORM}.$1"; then
          STAGES+=("${PLATFORM}.$1")
        elif section_exists "$1"; then
          STAGES+=("$1")
        else
          log_error "$ICON_FAIL Etapa '$1' não encontrada."
          exit 1
        fi
        ;;
    esac
    shift
  done

  if ((ALL)); then
    while IFS= read -r line; do
      section=$(get_section_name "$line")
      [[ -z "$section" ]] && continue
      if [[ "$section" == "${PLATFORM}."* ]]; then
        STAGES+=("$section")
      elif [[ "$section" != *.* ]]; then
        STAGES+=("$section")
      fi
    done <"$CONFIG"
  fi

  if [[ ${#STAGES[@]} -eq 0 ]]; then
    echo "Uso: $0 [--strict] [--only-missing] [--revert] [--preview] <etapa1> [...] ou $0 --all"
    echo
    echo "Opções:"
    echo "  --all           Executa todas as etapas definidas na configuração."
    echo "  --strict        Interrompe na primeira falha."
    echo "  --only-missing  Executa somente etapas que não estejam instaladas."
    echo "  --revert        Executa reversão."
    echo "  --preview       Mostra os comandos a serem executados antes de executar."
    echo "  stage           Lista de etapas a executar."
    exit 1
  fi
}

# ───────────────────────────────────────────────────────────────────────────────
# ▶️ Execução principal
# ───────────────────────────────────────────────────────────────────────────────

function main() {
  parse_args "$@"
  if ((REVERT)); then
    for stage in "${STAGES[@]}"; do
      run_revert_stage "$stage"
    done
  else
    for stage in "${STAGES[@]}"; do
      run_stage "$stage"
    done
  fi
  print_summary
}

main "$@"
